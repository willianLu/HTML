<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
        <title>解析段落文字</title>
        <style>
            html,
            body {
                padding: 0;
                margin: 0;
                width: 100%;
                height: 100%;
                line-height: 1.5;
            }
            * {
                margin: 0;
                padding: 0;
            }

            main {
                margin: 0 auto;
                width: 680px;
                font-size: 20px;
                /* line-height: 32px; */
                line-height: normal;
            }
        </style>
    </head>
    <body>
        <main class="main">天有不测风云，人有旦夕祸福。蜈蚣百足，行不及蛇；雄鸡两翼，飞不过鸦。马有千里之程，无骑不能自往；人有冲天之志，非运不能自通。We switch from an expect call to a match expression to move from crashing on an error to handling the error. Remember that parse returns a Result type and Result is an enum that has the variants Ok and Err. We’re using a match expression here, as we did with the Ordering result of the cmp method.</main>
        <div class="other">
            <img src="https://picsum.photos/200/300" alt="" />
            <div>其他内容啊，坎坎坷坷接口接口。</div>
        </div>
        <script>
            function handleInit() {
                const el = document.querySelector('.main')
                console.log('[ 原始内容 ]', [el])
                if (isPureTextNode(el)) {
                    parsePureText(el, 12)
                    parsePureText(el, 22)
                    parsePureText(el, 32)
                    parsePureText(el, 44)
                    parsePureText(el, 52)
                    parsePureText(el, 66)
                    parsePureText(el, 72)
                    parsePureText(el, 88)
                    parsePureText(el, 98)
                    parsePureText(el, 110)
                    parsePureText(el, 120)
                }
            }
            handleInit()
            function parsePureText(el, height) {
                const originalText = el.textContent
                const lineHeight = getLineHeight(el)
                console.log('[ 行高 ]', lineHeight)
                const row = Math.ceil(el.offsetHeight / lineHeight)
                const rTextCount = Math.floor(originalText.length / row)
                const cRow = Math.floor(height / lineHeight)
                // 创建Range对象来测量文本
                const range = document.createRange()
                const paragraphs = []
                let end = cRow < row ? cRow * rTextCount : originalText.length
                let isEnd = end && cRow < row ? false : true
                // 是否正向
                let inc = 0
                while (!isEnd) {
                    range.setStart(el.firstChild, 0)
                    range.setEnd(el.firstChild, end)
                    const rect = range.getBoundingClientRect()
                    if ((inc === 1 && rect.height > height) || (inc === -1 && rect.height <= height)) {
                        isEnd = true
                        end += inc === 1 ? -1 : 0
                        break
                    }
                    if (inc === 0) {
                        inc = rect.height > height ? -1 : 1
                    }
                    end += inc
                }

                paragraphs.push({
                    start: 0,
                    end: end ? end - 1 : 0,
                    text: originalText.substring(0, end),
                })
                paragraphs.push({
                    start: end,
                    end: cRow < row ? originalText.length - 1 : end,
                    text: originalText.substring(end),
                })
                console.log('分段结果:', paragraphs)
            }
            function getLineHeight(el) {
                const style = window.getComputedStyle(el)
                const lineHeight = style.lineHeight
                if (lineHeight === 'normal') {
                    const range = document.createRange()
                    range.setStart(el.firstChild, 0)
                    range.setEnd(el.firstChild, 1)
                    const rect = range.getBoundingClientRect()
                    return rect.height
                }
                if (lineHeight.includes('px')) {
                    return parseFloat(lineHeight)
                }
                const fontSize = parseFloat(style.fontSize)
                if (lineHeight.includes('em')) {
                    return parseFloat(lineHeight) * fontSize
                } else if (lineHeight.includes('%')) {
                    return (parseFloat(lineHeight) / 100) * fontSize
                }
                return parseFloat(lineHeight) * fontSize
            }
            // 检查是否为纯文本节点
            function isPureTextNode(el) {
                return el.childNodes.length === 1 && el.childNodes[0].nodeType === Node.TEXT_NODE
            }
        </script>
    </body>
</html>
